#!/usr/bin/env bash
#
set -eo pipefail

export GH_PAGER="cat"

BASEDIR=$(dirname "$0")
#shellcheck disable=SC1091
source "$BASEDIR/ghcli-common.sh"
POLL_INTERVAL_SECS=${GH_POLL_INTERVAL_SECS:-30}
GH_MERGE_TRAIN_REBASE=${GH_MERGE_TRAIN_REBASE:-"--rebase"}
GH_MERGE_TRAIN_MAX_ATTEMPTS=${GH_MERGE_TRAIN_MAX_ATTEMPTS:-5}

usage() {
  cat <<EOF

Usage: gh-merge-train [pr_number...]

This is a fake merge train that rebases, approves, and squash-merges each argument

In effect it takes some toil out of your life because we end up with this:

gh-merge-train 25 26 27
for PR in 25 26 27 do
  // retry if failure, so pay attention, because a conflict will mean an infinite loop
  gh pr update-branch PR --rebase
  while in_progress do
    gh pr checks PR --json "state,name" | jq -c ".[]" etc.
  done
  if success then
    gh pr review --approve $i
    gh squash-merge $i --use-default-msg
  fi
done

EOF
  exit 1
}

__bot_squash_merge_param() {
  local pr_number=$1
  local is_bot="false"
  is_bot=$(gh pr view "$pr_number" --json "author" --jq ".author.is_bot")
  if [[ "$is_bot" == "true" ]]; then
    echo "--use-default-msg"
  else
    echo ""
  fi
}

__check_status() {
  local pr_number=$1
  local successCount=0
  local inProgressCount=0
  local failureCount=0
  local lineCount=0
  local status

  buildStatusJson=$(gh pr checks "$pr_number" --json "name,state" | jq -c '.[]')
  if [[ -n "$buildStatusJson" ]]; then
    while IFS= read -r line; do
      lineCount=$((lineCount + 1))
			status="$(echo "$line" | jq -r '.state')"
      case "$status" in
      IN_PROGRESS | PENDING)
        inProgressCount=$((inProgressCount + 1))
        ;;
      SUCCESS)
        successCount=$((successCount + 1))
        ;;
      *)
        failureCount=$((failureCount + 1))
        ;;
      esac
    done <<<"$buildStatusJson"
    if [[ "$successCount" == "$lineCount" ]]; then
      echo "SUCCESSFUL"
    elif [[ $failureCount -gt 0 ]]; then
      echo "FAILED"
    else
      echo "IN_PROGRESS"
    fi
  else
    echo "No Checks in progress?"
  fi
}

__wait_for_checks() {
  local pr_number="$1"
  local buildStatus="IN_PROGRESS"
  while [[ "$buildStatus" == "IN_PROGRESS" ]]; do
    buildStatus="$(__check_status "$pr_number")"
    if [[ "$buildStatus" == "IN_PROGRESS" ]]; then
      echo "ðŸ”Ž ...$pr_number still has checks; waiting for ${POLL_INTERVAL_SECS}s"
      sleep "$POLL_INTERVAL_SECS"
    fi
  done
  if [[ "$buildStatus" != "SUCCESSFUL" ]]; then
    echo "$pr_number builds: $buildStatus"
    exit 1
  fi
}

__approve_if_not_author() {
  local pr_number="$1"
	local pr_author=""
	local me=""

	me=$(gh_whoami)
	pr_author="$(gh pr view "$pr" --json "author" | jq -r '.author.login')"
	echo "â„¹ï¸ PR Authored by $pr_author"
	if [[ "$me" != "$pr_author" ]]; then
		if ! gh pr review --approve "$pr_number" ; then
			echo "âš ï¸ Failed to approve, this might not matter. If it does then gh squash-merge should break..."
		fi
	fi
}

__approve_then_merge() {
  local pr_number="$1"
	__approve_if_not_author "$pr_number"
  gh squash-merge "$pr_number" $(__bot_squash_merge_param "$pr_number")
}

__update_branch() {
  local pr_number="$1"
	local updateCount=0
	echo "â„¹ï¸ Update branching using gh pr update-branch $pr_number $GH_MERGE_TRAIN_REBASE"
  while ! gh pr update-branch "$pr_number" "$GH_MERGE_TRAIN_REBASE"; do
		updateCount=$((updateCount + 1))
    if [[ "$updateCount" -ge "$GH_MERGE_TRAIN_MAX_ATTEMPTS" ]]; then
      echo -e "\nðŸš« Branch update failed too many times"
      exit 1
		else
			echo "Rebase failed. Retrying in $POLL_INTERVAL_SECS seconds..."
			sleep "$POLL_INTERVAL_SECS"
    fi
  done
}

{
  if [[ "$#" -eq 0 ]]; then
    usage
  fi
  for pr in "$@"; do
    echo "â„¹ï¸ Working on $(gh pr view "$pr" --json "url" | jq -r '.url')"
    __update_branch "$pr"
    # sad but sometimes the checks don't start quick enough
    sleep "$POLL_INTERVAL_SECS"
    __wait_for_checks "$pr"
    __approve_then_merge "$pr"
  done
}
